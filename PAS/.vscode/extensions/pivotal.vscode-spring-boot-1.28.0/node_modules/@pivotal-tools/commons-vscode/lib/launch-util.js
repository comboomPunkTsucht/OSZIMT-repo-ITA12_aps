'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListenablePreferenceSetting = exports.activate = void 0;
const VSCode = require("vscode");
const Path = require("path");
const FS = require("fs");
const PortFinder = require("portfinder");
const Net = require("net");
const CommonsCommands = require("./commands");
const vscode_languageclient_1 = require("vscode-languageclient");
const node_1 = require("vscode-languageclient/node");
const vscode_1 = require("vscode");
const vscode_jsonrpc_1 = require("vscode-jsonrpc");
const P2C = require("vscode-languageclient/lib/common/protocolConverter");
const highlight_service_1 = require("./highlight-service");
const util_1 = require("util");
const jvm_launch_utils_1 = require("@pivotal-tools/jvm-launch-utils");
const classpath_1 = require("./classpath");
const code_lens_service_1 = require("./code-lens-service");
const java_data_1 = require("./java-data");
const p2c = P2C.createConverter(undefined, undefined);
PortFinder.basePort = 45556;
const DEBUG_ARG = '-agentlib:jdwp=transport=dt_socket,server=y,address=8000,suspend=y';
function getUserDefinedJvmHeap(wsOpts, dflt) {
    if (!wsOpts) {
        return dflt;
    }
    let javaOptions = wsOpts.get("java");
    return (javaOptions && javaOptions.heap) || dflt;
}
function isCheckingJVM(wsOpts) {
    if (!wsOpts) {
        return true;
    }
    return wsOpts.get("checkJVM");
}
function getUserDefinedJvmArgs(wsOpts) {
    const dflt = [];
    if (!wsOpts) {
        return dflt;
    }
    let javaOptions = wsOpts.get("java");
    return javaOptions && javaOptions.vmargs || dflt;
}
function getSpringUserDefinedJavaHome(wsOpts, log) {
    let javaHome = null;
    if (wsOpts) {
        let javaOptions = wsOpts.get("java");
        javaHome = javaOptions && javaOptions.home;
    }
    if (!javaHome) {
        log.appendLine('"spring-boot.ls.java.home" setting not specified or empty value');
    }
    else if (!FS.existsSync(javaHome)) {
        log.appendLine('"spring-boot.ls.java.home" points to folder that does NOT exist: ' + javaHome);
        javaHome = null;
    }
    else {
        log.appendLine('Trying to use "spring-boot.ls.java.home" value: ' + javaHome);
    }
    return javaHome;
}
function getJdtUserDefinedJavaHome(log) {
    var _a;
    let javaHome = (_a = VSCode.workspace.getConfiguration('java')) === null || _a === void 0 ? void 0 : _a.get('home');
    if (!javaHome) {
        log.appendLine('"java.home" setting not specified or empty value');
    }
    else if (!FS.existsSync(javaHome)) {
        log.appendLine('"java.home" points to folder that does NOT exist: ' + javaHome);
        javaHome = null;
    }
    else {
        log.appendLine('Trying to use "java.home" value: ' + javaHome);
    }
    return javaHome;
}
function activate(options, context) {
    if (options.CONNECT_TO_LS) {
        return VSCode.window.showInformationMessage("Start language server")
            .then((x) => connectToLS(context, options));
    }
    else {
        const clientOptions = options.clientOptions;
        const outChennalName = options.extensionId + "-debug-log";
        clientOptions.outputChannel = VSCode.window.createOutputChannel(outChennalName);
        clientOptions.outputChannelName = outChennalName;
        clientOptions.outputChannel.appendLine("Activating '" + options.extensionId + "' extension");
        let findJRE = options.preferJdk ? jvm_launch_utils_1.findJdk : jvm_launch_utils_1.findJvm;
        return findJRE(getSpringUserDefinedJavaHome(options.workspaceOptions, clientOptions.outputChannel)
            || getJdtUserDefinedJavaHome(clientOptions.outputChannel), msg => clientOptions.outputChannel.appendLine(msg))
            .catch(error => {
            VSCode.window.showErrorMessage("Error trying to find JVM: " + error);
            return Promise.reject(error);
        })
            .then((jvm) => {
            if (!jvm) {
                VSCode.window.showErrorMessage("Couldn't locate java in $JAVA_HOME or $PATH");
                return;
            }
            let javaExecutablePath = jvm.getJavaExecutable();
            clientOptions.outputChannel.appendLine("Found java executable: " + javaExecutablePath);
            let version = jvm.getMajorVersion();
            if (version < 11) {
                VSCode.window.showErrorMessage(`Spring Tools Language Server requires Java 11 or higher to be launched. Current Java ${javaExecutablePath}.\n
                    \n
                    (Note Java 8 can still be used in your own projects. Java 11 is only required to launch the Spring Tools Language Server process)`, {});
                return;
            }
            clientOptions.outputChannel.appendLine("isJavaEightOrHigher => true");
            if (process.env['SPRING_LS_USE_SOCKET']) {
                return setupLanguageClient(context, createServerOptionsForPortComm(options, context, jvm), options);
            }
            else {
                return setupLanguageClient(context, createServerOptions(options, context, jvm), options);
            }
        });
    }
}
exports.activate = activate;
function createServerOptions(options, context, jvm, port) {
    const executable = Object.create(null);
    const execOptions = Object.create(null);
    execOptions.env = Object.assign(process.env);
    // execOptions.cwd = VSCode.workspace.rootPath
    executable.options = execOptions;
    executable.command = jvm.getJavaExecutable();
    const vmArgs = prepareJvmArgs(options, context, jvm, port);
    addCpAndLauncherToJvmArgs(vmArgs, options, context);
    executable.args = vmArgs;
    return executable;
}
function createServerOptionsForPortComm(options, context, jvm) {
    return () => new Promise((resolve, reject) => {
        PortFinder.getPort((err, port) => {
            Net.createServer(socket => {
                options.clientOptions.outputChannel.appendLine('Child process connected on port ' + port);
                resolve({
                    reader: socket,
                    writer: socket
                });
            })
                .listen(port, () => {
                let processLaunchoptions = {
                    cwd: VSCode.workspace.rootPath
                };
                const args = prepareJvmArgs(options, context, jvm, port);
                if (options.explodedLsJarData) {
                    const explodedLsJarData = options.explodedLsJarData;
                    const lsRoot = Path.resolve(context.extensionPath, explodedLsJarData.lsLocation);
                    // Add classpath
                    const classpath = [];
                    classpath.push(Path.resolve(lsRoot, 'BOOT-INF/classes'));
                    classpath.push(`${Path.resolve(lsRoot, 'BOOT-INF/lib')}${Path.sep}*`);
                    jvm.mainClassLaunch(explodedLsJarData.mainClass, classpath, args, processLaunchoptions);
                }
                else {
                    // Start the child java process
                    const launcher = findServerJar(Path.resolve(context.extensionPath, 'jars'));
                    jvm.jarLaunch(launcher, args, processLaunchoptions);
                }
            });
        });
    });
}
function prepareJvmArgs(options, context, jvm, port) {
    const DEBUG = options.DEBUG;
    const jvmHeap = getUserDefinedJvmHeap(options.workspaceOptions, options.jvmHeap);
    const jvmArgs = getUserDefinedJvmArgs(options.workspaceOptions);
    let logfile = options.workspaceOptions.get("logfile") || "/dev/null";
    //The logfile = '/dev/null' is handled specifically by the language server process so it works on all OSs.
    options.clientOptions.outputChannel.appendLine('Redirecting server logs to ' + logfile);
    const args = [
        '-Dsts.lsp.client=vscode',
        '-Dsts.log.file=' + logfile,
        '-XX:TieredStopAtLevel=1'
    ];
    if (port && port > 0) {
        args.push('-Dspring.lsp.client-port=' + port);
        args.push('-Dserver.port=' + port);
    }
    if (isCheckingJVM(options.workspaceOptions) && options.checkjvm) {
        options.checkjvm(context, jvm);
    }
    if (jvmHeap && !hasHeapArg(jvmArgs)) {
        args.unshift("-Xmx" + jvmHeap);
    }
    if (jvmArgs) {
        args.unshift(...jvmArgs);
    }
    if (DEBUG) {
        args.unshift(DEBUG_ARG);
    }
    if (options.explodedLsJarData) {
        const explodedLsJarData = options.explodedLsJarData;
        const lsRoot = Path.resolve(context.extensionPath, explodedLsJarData.lsLocation);
        // Add config file if needed
        if (explodedLsJarData.configFileName) {
            args.push(`-Dspring.config.location=file:${Path.resolve(lsRoot, `BOOT-INF/classes/${explodedLsJarData.configFileName}`)}`);
        }
    }
    return args;
}
function addCpAndLauncherToJvmArgs(args, options, context) {
    if (options.explodedLsJarData) {
        const explodedLsJarData = options.explodedLsJarData;
        const lsRoot = Path.resolve(context.extensionPath, explodedLsJarData.lsLocation);
        // Add classpath
        const classpath = [];
        classpath.push(Path.resolve(lsRoot, 'BOOT-INF/classes'));
        classpath.push(`${Path.resolve(lsRoot, 'BOOT-INF/lib')}${Path.sep}*`);
        args.unshift(classpath.join(Path.delimiter));
        args.unshift('-cp');
        args.push(explodedLsJarData.mainClass);
    }
    else {
        // Start the child java process
        args.push('-jar');
        const launcher = findServerJar(Path.resolve(context.extensionPath, 'jars'));
        args.push(launcher);
    }
}
function hasHeapArg(vmargs) {
    if (vmargs) {
        return vmargs.some(a => a.startsWith("-Xmx"));
    }
    return false;
}
function findServerJar(jarsDir) {
    let serverJars = FS.readdirSync(jarsDir).filter(jar => jar.indexOf('language-server') >= 0 &&
        jar.endsWith(".jar"));
    if (serverJars.length == 0) {
        throw new Error("Server jar not found in " + jarsDir);
    }
    if (serverJars.length > 1) {
        throw new Error("Multiple server jars found in " + jarsDir);
    }
    return Path.resolve(jarsDir, serverJars[0]);
}
function connectToLS(context, options) {
    let connectionInfo = {
        port: 5007
    };
    let serverOptions = () => {
        let socket = Net.connect(connectionInfo);
        let result = {
            writer: socket,
            reader: socket
        };
        return Promise.resolve(result);
    };
    return setupLanguageClient(context, serverOptions, options);
}
function setupLanguageClient(context, createServer, options) {
    // Create the language client and start the client.
    let client = new node_1.LanguageClient(options.extensionId, options.extensionId, createServer, options.clientOptions);
    client.registerProposedFeatures();
    util_1.log("Proposed protocol extensions loaded!");
    if (options.TRACE) {
        client.trace = vscode_jsonrpc_1.Trace.Verbose;
    }
    let progressNotification = new vscode_jsonrpc_1.NotificationType("sts/progress");
    let highlightNotification = new vscode_jsonrpc_1.NotificationType("sts/highlight");
    let moveCursorRequest = new vscode_languageclient_1.RequestType("sts/moveCursor");
    let disposable = client.start();
    const codeLensListanableSetting = options.highlightCodeLensSettingKey ? new ListenablePreferenceSetting(options.highlightCodeLensSettingKey) : undefined;
    let progressService = new ProgressService();
    let highlightService = new highlight_service_1.HighlightService();
    const codelensService = new code_lens_service_1.HighlightCodeLensProvider();
    let codeLensProviderSubscription;
    CommonsCommands.registerCommands(context);
    context.subscriptions.push(disposable);
    context.subscriptions.push(progressService);
    context.subscriptions.push(highlightService);
    function toggleHighlightCodeLens() {
        if (!codeLensProviderSubscription && codeLensListanableSetting.value) {
            codeLensProviderSubscription = VSCode.languages.registerCodeLensProvider(options.clientOptions.documentSelector, codelensService);
            context.subscriptions.push(codeLensProviderSubscription);
        }
        else if (codeLensProviderSubscription) {
            codeLensProviderSubscription.dispose();
            const idx = context.subscriptions.indexOf(codeLensProviderSubscription);
            if (idx >= 0) {
                context.subscriptions.splice(idx, 1);
            }
            codeLensProviderSubscription = null;
        }
    }
    if (codeLensListanableSetting) {
        toggleHighlightCodeLens();
        codeLensListanableSetting.onDidChangeValue(() => toggleHighlightCodeLens());
    }
    return client.onReady().then(() => {
        client.onNotification(progressNotification, (params) => {
            progressService.handle(params);
        });
        client.onNotification(highlightNotification, (params) => {
            highlightService.handle(params);
            if (codeLensListanableSetting && codeLensListanableSetting.value) {
                codelensService.handle(params);
            }
        });
        client.onRequest(moveCursorRequest, (params) => {
            let editors = VSCode.window.visibleTextEditors;
            for (let editor of editors) {
                if (editor.document.uri.toString() == params.uri) {
                    let cursor = p2c.asPosition(params.position);
                    let selection = new VSCode.Selection(cursor, cursor);
                    editor.selections = [selection];
                }
            }
            return { applied: true };
        });
        classpath_1.registerClasspathService(client);
        java_data_1.registerJavaDataService(client);
        return client;
    });
}
function correctBinname(binname) {
    if (process.platform === 'win32')
        return binname + '.exe';
    else
        return binname;
}
class ProgressHandle {
    constructor(progress, finish) {
        this.progress = progress;
        this.finish = finish;
    }
    updateStatus(message, increment) {
        this.progress.report({
            message,
            increment
        });
    }
    complete() {
        this.finish();
    }
}
class ProgressService {
    constructor() {
        this.status = new Map();
    }
    handle(params) {
        const progressHandler = this.status.get(params.id);
        if (progressHandler) {
            if (params.statusMsg) {
                progressHandler.updateStatus(params.statusMsg, -1);
            }
            else {
                progressHandler.complete();
            }
        }
        else {
            if (params.statusMsg) {
                vscode_1.window.withProgress({
                    location: vscode_1.ProgressLocation.Notification,
                    title: "",
                    cancellable: false
                }, progress => new Promise(resolve => {
                    this.status.set(params.id, new ProgressHandle(progress, resolve));
                    progress.report({
                        message: params.statusMsg,
                        increment: -1
                    });
                }));
            }
        }
    }
    dispose() {
        if (this.status) {
            for (let handler of this.status.values()) {
                handler.complete();
            }
        }
        this.status = null;
    }
}
class ListenablePreferenceSetting {
    constructor(section) {
        this.section = section;
        this._onDidChangeValue = new vscode_1.EventEmitter();
        VSCode.workspace.onDidChangeConfiguration(e => {
            console.log('Settings changed! value = ' + this.value);
            if (e.affectsConfiguration(this.section)) {
                this._onDidChangeValue.fire();
            }
        });
    }
    get value() {
        return VSCode.workspace.getConfiguration().get(this.section);
    }
    get onDidChangeValue() {
        return this._onDidChangeValue.event;
    }
}
exports.ListenablePreferenceSetting = ListenablePreferenceSetting;
//# sourceMappingURL=launch-util.js.map